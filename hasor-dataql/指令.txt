// -------------------------------------------------------------------------- //
// --            特殊路由说明                                                   //
// -------------------------------------------------------------------------- //

路由：
    可选的符号：@、#、$

    一般路由取值原理：
        首先将环境栈顶对象 copy 到数据栈顶，然后在数据栈顶的元素身上执行路由取值。

    $ss.sss.sss 是一般路由的升级形式：
        # 表示环境栈顶(同一般路由)，@ 表示第二层环境栈元素，$ 根环境栈元素（每一个结果转换都会产生一层环境栈）

    ${xxxx} 自定义取值


路由中单独只使用符号
    @，取上一层数据栈的数据
    #，取当前数据栈的数据
    $，取数据栈栈根数据
    例如：
        var _0 = [1,2,3,4,5,6] ; return ${_0} => { 'a': $ }  -> 结果为 { 'a' : 1 }

函数和调用：
    DataQL 中的对象都是数据对象，类似 'var a = abs(123)' 这样的语句执行实际是，从环境对象上获取 abs 属性。
    而 abs 属性是一个 UDF 类型对象。这一点不同于 java 的对象方法调用。

数组索引
    例：
        var list = [0,1,2,3,4,5,6,7,8,9] 10个元素
    索引编号
        正数，从前向后数，从0开始。
        负数，从后向前数，从1开始。
    正向索引：list[3] = 4 or list[5] = 5
    反向索引：list[-3] = 7 or list[-5] = 5
    索引溢出
        正向索引溢出：list[100]，取最后一个。
        反向索引溢出：list[-100]，取第一个。

编译变量（compilerVar）
    编译变量名，编译变量的作用相当于在脚本中预先 执行 var xxx = null;
    其意义在于在编译期就把脚本中尚未定义过的变量预先进行声明从而免去通过 ${...} 或类似方式查找变量。

// -------------------------------------------------------------------------- //
// --            数值计算                                                      //
// -------------------------------------------------------------------------- //

数值类型和对应 java 类型，数值表示范围遵循 java 规范：
    * byte > Byte
    * short > Short
    * int > Integer
    * long > Long
    * float > Float
    * double > Double
    * big > BigInteger or BigDecimal

数值计算宽度：
    * 整数：byte、short、int(默认)、long、big
    * 浮点数：float、double(默认)、big

修改默认数值计算宽度
    * option MIN_DECIMAL_WIDTH = double
    * option MIN_INTEGER_WIDTH = int

关于浮点数计算精度丢失问题：
    * 可以将浮点数的数值宽度提升到 big 就会以 BigDecimal 方式进行计算以解决精度丢失问题。缺点是性能损耗。

浮点数计算舍入精度
    * 默认 20 位

修改浮点数计算舍入精度
    * option MAX_DECIMAL_DIGITS = 20

舍入规则
    * UP：向远离零的方向舍入。舍弃非零部分，并将非零舍弃部分相邻的一位数字加一。
    * DOWN：向接近零的方向舍入。舍弃非零部分，同时不会非零舍弃部分相邻的一位数字加一，采取截取行为。
    * CEILING：向正无穷的方向舍入。如果为正数，舍入结果同ROUND_UP一致；如果为负数，舍入结果同ROUND_DOWN一致。注意：此模式不会减少数值大小。
    * FLOOR：向负无穷的方向舍入。如果为正数，舍入结果同ROUND_DOWN一致；如果为负数，舍入结果同ROUND_UP一致。注意：此模式不会增加数值大小。
    * HALF_UP：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分>= 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“四舍五入”。
    * HALF_DOWN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向下舍入的舍入模式。如果舍弃部分> 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“五舍六入”。
    * HALF_EVEN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则相邻的偶数舍入。如果舍弃部分左边的数字奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意：在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况，如果前一位为奇数，则入位，否则舍去。*/
    * UNNECESSARY：断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。

更换舍入规则
    * 例：option NUMBER_ROUNDING = "HALF_EVEN"

// -------------------------------------------------------------------------- //
// --            QIL 文件格式                                                  //
// -------------------------------------------------------------------------- //
Length-Encoded Integer Type
    0xFB             ，Null
    0xFC + 2字节(数字)，值范围：>= 251             && < 2^16 (65536)
    0xFD + 3字节(数字)，值范围：>= 2^16 (65536)    && < 2^24 (16777216)
    0xFE + 8字节(数字)，值范围：>= 2^24 (16777216)



byte[4] magic number        QIL 文件格式魔数
byte[4] dataPool Length     数据池条目总数





    如果是 0xFC 开头，那么
    >如果该值 < 251，则将其存储为一个字节的整数.
    >如果该值 >= 251  则将其存储为 fc + 2字节整数.
    >如果该值 >= 2^16 且 < 2^24，则将其存储为fd + 3字节整数.
    >如果该值 >= 2^24 且 < 2^64，则它将存储为fe + 8字节整数.

    byte[1]
    byte[2]
    byte[2]

    byte[2] att-length      数据大小
    ....
byte[8] dataPool Length     数据池大小
    byte[n] dataBody        池数据

byte[2] compilerVar count   编译变量数
    byte[4] att-length      在数据池中的编号

byte[4] InsetSet Size       指令序列数量
    byte[4]                 指令序列中的指令数量
        byte[1]             指令号
        byte[1]             指令属性数
            byte[4]         属性值在数据池中的编号
            byte[4]         属性值在数据池中的编号
        ...
    ...


// -------------------------------------------------------------------------- //
// --            语法                                                         //
// -------------------------------------------------------------------------- //
语句：
    if ... else if ... else ...
    var <name> = ...
    option <key> = <value>
    import ... as <name>
    return <code>, ...
    throw <code>, ...
    exit <code>, ...

lambda定义
    var a = (p1,p2) -> { return abc; }

结果转换
    var a = b => { ... }
    var a = b => [ ... ]
    var a = b => [ { ... },{ ... } ]











1。 parser 失败的时候，不应该继续尝试解析  g4。
2。 定位行号
