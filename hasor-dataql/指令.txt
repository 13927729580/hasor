// -------------------------------------------------------------------------- 数据指令
LDC_D   // 将数字压入栈（例：LDC_D 12345）
        - 参数说明：共1参数；参数1：数据；
        - 栈行为：消费0，产出1
        - 堆行为：无

LDC_B   // 将布尔数据压入栈（例：INSN_B true）
        - 参数说明：共1参数；参数1：数据；
        - 栈行为：消费0，产出1
        - 堆行为：无

LDC_S   // 将字符串数据压入栈（例：LDC_S "ssssss"）
        - 参数说明：共1参数；参数1：数据；
        - 栈行为：消费0，产出1
        - 堆行为：无

LDC_N   // 将null压入栈（例：INSN_N）
        - 参数说明：共0参数；
        - 栈行为：消费0，产出1
        - 堆行为：无

NEW_O   // 构造一个键值对对象并压入栈
        - 参数说明：共0参数；
        - 栈行为：消费0，产出1
        - 堆行为：无

NEW_A   // 构造一个集合对象并压入栈
        - 参数说明：共0参数；
        - 栈行为：消费0，产出1
        - 堆行为：无

// -------------------------------------------------------------------------- 存储指令
STORE   // 栈顶数据存储到堆（例：STORE，2）
        - 参数说明：共1参数；参数1：存入堆的位置；
        - 栈行为：消费1，产出0
        - 堆行为：存入数据

LOAD    // 从指定深度的堆中加载n号元素到栈（例：LOAD 1 ,1 ）
        - 参数说明：共2参数；参数1：堆深度；参数2：元素序号；
        - 栈行为：消费0，产出1
        - 堆行为：取出数据（不删除）

GET     // 获取栈顶对象元素的属性（例：GET,"xxxx"）
        - 参数说明：共1参数；参数1：属性名称（Map的Key 或 对象的属性名）
        - 栈行为：消费1，产出1
        - 堆行为：无

PUT     // 将栈顶对象元素放入对象元素中（例：PUT,"xxxx"）
        - 参数说明：共1参数；参数1：属性名称（Map的Key 或 对象的属性名）
        - 栈行为：消费1，产出0
        - 堆行为：无

PULL    // 栈顶元素是一个集合类型，获取集合的指定索引元素。（例：PULL 123）
        - 参数说明：共1参数；参数1：元素位置(负数表示从后向前，正数表示从前向后)
        - 栈行为：消费1，产出1
        - 堆行为：无

PUSH    // 将栈顶元素压入集合（例：PUSH）
        - 参数说明：共0参数；
        - 栈行为：消费1，产出0
        - 堆行为：无

// -------------------------------------------------------------------------- 结束指令
EXIT    // 结束所有指令序列的执行并返回数据和状态
        - 参数说明：共1参数；参数1：退出码
        - 栈行为：消费1，产出0
        - 堆行为：无

RETURN  // 结束当前指令序列的执行，并返回数据和状态给上一个指令序列。如果没有上一个指令序列那么结束整个查询
        - 参数说明：共1参数；参数1：返回码
        - 栈行为：消费1，产出0
        - 堆行为：无

THROW   // 结束所有指令序列的执行，并抛出异常
        - 参数说明：共1参数；参数1：错误码
        - 栈行为：消费1，产出0
        - 堆行为：无

// -------------------------------------------------------------------------- 运算指令
UO      // 一元运算
        - 参数说明：共1参数；参数1：一元操作符
        - 栈行为：消费1，产出1
        - 堆行为：无

DO      // 二元运算，堆栈【第一个操作数，第二个操作数】  第一操作数 * 第二操作数
        - 参数说明：共1参数；参数1：二元操作符
        - 栈行为：消费2，产出1
        - 堆行为：无

// -------------------------------------------------------------------------- 控制指令
IF      // if 条件判断，如果条件判断失败那么 GOTO 到指定位置，否则继续往下执行
        - 参数说明：共1参数；参数1：GOTO 的位置
        - 栈行为：消费1，产出0
        - 堆行为：无

GOTO    // 执行跳转
        - 参数说明：共1参数；参数1：GOTO 的位置
        - 栈行为：消费0，产出0
        - 堆行为：无

OPT     // 环境配置，影响执行引擎的参数选项。
        - 参数说明：共2参数；参数1：选项Key；参数2：选项Value
        - 栈行为：消费2，产出0
        - 堆行为：无

CAST_I  // 将栈顶元素转换为迭代器，作为迭代器有三个特殊操作：data(数据)、next(移动到下一个，如果成功返回true)
        - 参数说明：共0参数
        - 栈行为：消费1，产出1
        - 堆行为：无

CAST_O  // 将栈顶元素转换为一个对象，如果是集合那么取第一条记录（可以通过CAST_I方式解决，但会多消耗大约8条左右的指令）
        - 参数说明：共0参数
        - 栈行为：消费1，产出1
        - 堆行为：无

LOAD_C  // 加载自定义路由
        - 参数说明：共1参数；参数1：@#$符号之一
        - 栈行为：消费0，产出1
        - 堆行为：无

POP     // 丢弃栈顶数据
        - 参数说明：共0参数；
        - 栈行为：消费1，产出0
        - 堆行为：无

E_PUSH  // 取出当前栈顶数据，并压入环境栈
        - 参数说明：共0参数；
        - 栈行为：消费1，产出0
        - 环境栈行为：消费0，产出1
        - 堆行为：无

E_POP   // 丢弃环境栈顶的元素
        - 参数说明：共0参数；
        - 栈行为：消费0，产出0
        - 环境栈行为：消费1，产出0
        - 堆行为：无

E_LOAD  // 加载环境栈顶的数据到数据栈
        - 参数说明：共1参数；参数1：操作符号@#$
        - 栈行为：消费0，产出1
        - 环境栈行为：消费0，产出0
        - 堆行为：无

// -------------------------------------------------------------------------- 函数指令
CALL    // 发起服务调用（例：CALL,2）
        - 参数说明：共1参数；参数1：发起调用时需要用到的调用参数个数 n
        - 栈行为：消费：n + 1（n是参数，1是函数入口），产出1
        - 堆行为：无

M_DEF   // 函数定义，将栈顶元素转换为 UDF
        - 参数说明：共0参数；
        - 栈行为：消费1，产出1
        - 堆行为：无

M_TYP   // 加载一个类型对象到栈顶.
        - 参数说明：共1参数；参数为要加载的Bean名
        - 栈行为：消费0，产出1
        - 堆行为：无


M_REF   // 引用另一处的指令序列地址，并将其作为 UDF 形态存放到栈顶。lambda 被调用的开始会像栈顶放入一个入参数组。
        - 参数说明：共1参数；参数1：内置lambda函数的入口地址
        - 栈行为：消费0，产出1
        - 堆行为：无

M_STAR  // 和M_REF指令配对，用于修整 lambda 调用的入参修整
        - 参数说明：共1参数；参数1：表示lambda函数调用时入参的个数
        - 栈行为：消费1，产出0
        - 堆行为：根据参数1的数量存入对应数量的数据，数据来源是栈顶的元素。


LOCAL   // 将入参存入堆，也用于标记变量名称
        - 参数说明：共2参数；参数1：调用时的入参位置；参数2：参数名助记符，无实际用处；
        - 栈行为：消费0，产出0
        - 堆行为：存入数据

// -------------------------------------------------------------------------- 辅助指令
LABEL   // 协助GOTO定位用，无实际作用

LINE    // 行号，无实际作用


// -------------------------------------------------------------------------- //
// --            特殊路由说明                                                   //
// --                                                                         //
// -------------------------------------------------------------------------- //

路由：
    可选的符号：@、#、$

    一般路由取值原理：
        首先将环境栈顶对象 copy 到数据栈顶，然后在数据栈顶的元素身上执行路由取值。

    $ss.sss.sss 是一般路由的升级形式：
        # 表示环境栈顶(同一般路由)，@ 表示第二层环境栈元素，$ 根环境栈元素（每一个结果转换都会产生一层环境栈）

    ${xxxx} 自定义取值


路由中单独只使用符号的含义
    @，取上一层数据栈的数据
    #，取当前数据栈的数据
    $，取数据栈栈根数据
    例如：
        var _0 = [1,2,3,4,5,6] ; return ${_0} => { 'a': $ }  -> 结果为 { 'a' : 1 }

函数和调用：
    DataQL 中的对象都是数据对象，类似 'var a = abs(123)' 这样的语句执行实际是，从环境对象上获取 abs 属性。
    而 abs 属性是一个 UDF 类型对象。这一点不同于 java 的对象方法调用。

数组索引
    例：
        var list = [0,1,2,3,4,5,6,7,8,9] 10个元素
    索引编号
        正数，从前向后数，从0开始。
        负数，从后向前数，从1开始。
    正向索引：list[3] = 4 or list[5] = 5
    反向索引：list[-3] = 7 or list[-5] = 5
    索引溢出
        正向索引溢出：list[100]，取最后一个。
        反向索引溢出：list[-100]，取第一个。

编译变量（compilerVar）
    编译变量名，编译变量的作用相当于在脚本中预先 执行 var xxx = null;
    其意义在于在编译期就把脚本中尚未定义过的变量预先进行声明从而免去通过 ${...} 或类似方式查找变量。

// -------------------------------------------------------------------------- //
// --            数值计算                                                      //
// --                                                                         //
// -------------------------------------------------------------------------- //

数值类型和对应 java 类型，数值表示范围遵循 java 规范：
    * byte > Byte
    * short > Short
    * int > Integer
    * long > Long
    * float > Float
    * double > Double
    * big > BigInteger or BigDecimal

数值计算宽度：
    * 整数：byte、short、int(默认)、long、big
    * 浮点数：float、double(默认)、big

修改默认数值计算宽度
    * option MIN_DECIMAL_WIDTH = double
    * option MIN_INTEGER_WIDTH = int

关于浮点数计算精度丢失问题：
    * 可以将浮点数的数值宽度提升到 big 就会以 BigDecimal 方式进行计算以解决精度丢失问题。缺点是性能损耗。

浮点数计算舍入精度
    * 默认 20 位

修改浮点数计算舍入精度
    * option MAX_DECIMAL_DIGITS = 20

舍入规则
    * UP：向远离零的方向舍入。舍弃非零部分，并将非零舍弃部分相邻的一位数字加一。
    * DOWN：向接近零的方向舍入。舍弃非零部分，同时不会非零舍弃部分相邻的一位数字加一，采取截取行为。
    * CEILING：向正无穷的方向舍入。如果为正数，舍入结果同ROUND_UP一致；如果为负数，舍入结果同ROUND_DOWN一致。注意：此模式不会减少数值大小。
    * FLOOR：向负无穷的方向舍入。如果为正数，舍入结果同ROUND_DOWN一致；如果为负数，舍入结果同ROUND_UP一致。注意：此模式不会增加数值大小。
    * HALF_UP：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分>= 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“四舍五入”。
    * HALF_DOWN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向下舍入的舍入模式。如果舍弃部分> 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“五舍六入”。
    * HALF_EVEN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则相邻的偶数舍入。如果舍弃部分左边的数字奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意：在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况，如果前一位为奇数，则入位，否则舍去。*/
    * UNNECESSARY：断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。

更换舍入规则
    * 例：option NUMBER_ROUNDING = "HALF_EVEN"

// -------------------------------------------------------------------------- //
// --            QIL 文件格式                                                  //
// --                                                                         //
// -------------------------------------------------------------------------- //
Length-Encoded Integer Type
    0xFB             ，Null
    0xFC + 2字节(数字)，值范围：>= 251             && < 2^16 (65536)
    0xFD + 3字节(数字)，值范围：>= 2^16 (65536)    && < 2^24 (16777216)
    0xFE + 8字节(数字)，值范围：>= 2^24 (16777216)



byte[4] magic number        QIL 文件格式魔数
byte[4] dataPool Length     数据池条目总数





    如果是 0xFC 开头，那么
    >如果该值 < 251，则将其存储为一个字节的整数.
    >如果该值 >= 251  则将其存储为 fc + 2字节整数.
    >如果该值 >= 2^16 且 < 2^24，则将其存储为fd + 3字节整数.
    >如果该值 >= 2^24 且 < 2^64，则它将存储为fe + 8字节整数.

    byte[1]
    byte[2]
    byte[2]

    byte[2] att-length      数据大小
    ....
byte[8] dataPool Length     数据池大小
    byte[n] dataBody        池数据

byte[2] compilerVar count   编译变量数
    byte[4] att-length      在数据池中的编号

byte[4] InsetSet Size       指令序列数量
    byte[4]                 指令序列中的指令数量
        byte[1]             指令号
        byte[1]             指令属性数
            byte[4]         属性值在数据池中的编号
            byte[4]         属性值在数据池中的编号
        ...
    ...


// -------------------------------------------------------------------------- //
// --            语法                                                         //
// --                                                                         //
// -------------------------------------------------------------------------- //
语句：
    if ... else if ... else ...
    var <name> = ...
    option <key> = <value>
    import ... as <name>
    return <code>, ...
    throw <code>, ...
    exit <code>, ...

lambda定义
    var a = (p1,p2) -> { return abc; }

结果转换
    var a = b => { ... }
    var a = b => [ ... ]
    var a = b => [ { ... },{ ... } ]











1。 parser 失败的时候，不应该继续尝试解析  g4。
2。 定位行号
