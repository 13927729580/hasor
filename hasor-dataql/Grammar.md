# DataQL

## 介绍
&emsp;&emsp;DataQL（Data Query Language）DataQL 是一种查询语言，旨在通过提供直观、灵活的语法来描述客户端应用程序的数据需求和交互。
例如：下面这个 DataQL 从 user 函数中查询 id 为 4 的用户相关信息并返回给应用。与对标开源工具 GraphQL 相比也仅仅这一部分与其是类似的。
```
return userByID({'id': 4}) => {
    'name',
    'sex'
    'age',
}
```

&emsp;&emsp;数据的存储根据其业务形式通常是较为简单的，并不适合直接在页面上进行展示。因此开发页面的前端工程师需要为此做大量的工作。
例如：性别数据的字典映射。 为此您可以通过 DataQL 的表达式进行快速的转换。从而无需任何服务端和前端的开发。
```
return userByID({'id': 4}) => {
    'name',
    'sex' : (sex == 'F') ? '男' : '女' ,
    'age'
}
```

&emsp;&emsp;DataQL 也允许您定义一个查询函数来重用这一逻辑。
```
var sex_str = (sex) -> {
    return (sex == 'F' ? '男' : '女');
}
return userByID({'id': 4}) => {
    'name',
    'sex' : sex_str(sex),
    'age'
}
```

DataQL 有一些设计原则，这也使其成为有一定的特性。
- 层次结构：大多数产品开发都涉及到数据的层次结构，为了实现与这些应用程序结构的一致性，DataQL 查询结果是也是分层结构的。这与 GraphQL 是基本相同的。
- 数据为中心：DataQL 不局限于只为前端工程师提供支持，当然前端工程师是一个比较典型的场景。对于后端工程师而言也有通过 DataQL 来构建业务的可配置化实践。
- 弱类型：DataQL 系统中不会要求声明任何形式的类型结构，您只需要在需要需要的时候描述它们即可。
- 逻辑表达：DataQL 并不是一门脚本语言。相比Java、Python这类专门的语言而言它对逻辑的表达能力较弱，但它的一些增强特性使其在对数据查询的过程中有了一些脚本的能力。例如：表达式计算、对象取值、条件分支、lambda和函数。
- 查询复用：DataQL 允许您在编写查询语句中通过 import 导入其它查询脚本使其作为当前查询中的一部分以供使用，这个特性会让您更加合理的规划和涉及基于 DataQL 的查询系统。从而降低脚本维护成本。
- 编译运行：查询的执行是基于编译结果的。这与 GraphQL 有很大的不同。原则上说只要任何一门特定的语言实现了 DataQL 的指令集，DataQL 就可以无缝直接被该平台兼容。这是这种一次编译到处运行的设计理念。
- 扩展代码片段：这是主要面向后端应用场景的一项特性。基于扩展代码片段，允许一个 DataQL 查询中可以混合任意的其它脚本语句。一个典型的场景是：在 DataQL 中定义 SQL 语句并通过代码片段来执行它，最后在利用 DataQL 对查询结果进行处理。
- 类JavaScript语法：DataQL 的语法设计绝大部分风格来自于 JavaScript，这使得使用者的学习成本变得极低。您可以在最快半个小时之内就可以上手使用并投入到生产环境。

&emsp;&emsp;基于这些原则和特性，DataQL变为构建应用程序的强大而高效的环境。此外构建 DataQL 环境您不需要单独搭建任何服务器。
目前 DataQL 只提供了 Java 版的指令执行引擎，使用这个引擎您只需要依赖一个 Jar 包即可。这相比较 GraphQL 需要专门服务器而言您的引入成本变得无比小，任何一个Web应用或者Spring Boog的 jar 应用使用都变得非常容易。

&emsp;&emsp;以下正式的语法规范可以用来帮助您更深入的了解如何使用 DataQL 的所有特性。在不同的语言平台上下面这些语法是通用的，在某些细节上各个平台在数据处理中可能有一些差异。例如：浮点数精度问题、超大数的宽度上下限。

----

## 语法部分

### 1 源码文本
&emsp;&emsp;DataQL 文档表示建议使用 Unicode字符序列。但这并不是强制的，您可以通过 java.io.Reader 来读取您的字符流数据。顾本文不会强调您的编写查询语言所使用的字符集。

&emsp;&emsp;DataQL 支持单行注释和多行注释两种注释方式。与 JavaScript 一样，您可以使用："//"、"/* ... */" 的形式进行代码注释。被注释的代码会被语法解析器忽略。
- 单行注释：以 "//" 开头后面的当前换行符内的所有内容均为注释内容。
- 多行注释：以 "/\*" 开始直到遇到 "\*/" 为止，中间的所有内容均为注释。

### 2 词法记号

#### 2.1 空白字符
&emsp;&emsp;空白字符用于提高源文本的可读性，并作为标记之间的分隔，任何数量的空白都可能出现在任何标记之前或之后。标记之间的空白对于 DataQL 文档的语义意义并不重要。
- DataQL 会把这些字符识别为空白字符："(空格)"、"\t"、"\n"、"\r"、"\f"

#### 2.2 关键字
| 关键字 | 含义 |
| ------ | :----- |
| if     | 条件语句的引导词。 |
| else   | 用在条件语句中，表明当条件不成立时的分支。 |
| return | 三大退出指令之一，终止当前过程的执行并正常退出到上一个执行过程中。 |
| throw  | 三大退出指令之一，终止所有后续指令的执行并抛出异常。 |
| exit   | 三大退出指令之一，终止所有后续指令的执行并正常退出。 |
| var    | 执行一个查询动作，并把查询结果保存到临时变量中。 |
| run    | 仅仅执行查询动作，不保留查询的结果。 |
| hint   | 写在 DataQL 查询语句的最前面，用于设置一些执行选项参数。  |
| import | 将另外一个 DataQL 查询导入并作为一个 Udf 形式存在、或直接导入一个 Udf 到当前查询中。 |
| as     | 与 import 关键字配合使用，用作将导入的 Udf 命名为一个本地变量名。 |
| true   | 基础类型之一，表示 Boolean 的：真值。 |
| false  | 基础类型之一，表示 Boolean 的：假值。 |
| null   | 基础类型之一，表示 NULL 值。 |

#### 2.3 标识符
&emsp;&emsp;在编写 DataQL 中用来表示查询中的一些实体。例如：变量名、参数名
- 标识符必须满足正则表达式：[_a-zA-Z][_0-9a-zA-Z]*

#### 2.4 分割符
&emsp;&emsp;主要用于分割语义。例如：表达式计算中的提权；语句块的包裹；函数入参的圈定等等。DataQL 的分割符有下面几种：

| 分割符 | 含义 |
| ----- | :----- |
| ()    | 函数入参的圈定，表达式中的计算项提取权。 |
| {}    | 用来定义复合语句。 |
| []    | 对数据通过下标方式取值操作。 |
| ,     | 不同参数的分割；对象键值对或数组元素之间的分割。 |
| :     | 对象键值对，键和值之间的分割。 |
| ;     | 语句的结束，DataQL 会自动推断语句结束，因此语句结束分割符并不是必须的。 |

#### 2.5 运算符

数值运算

| 助记符 | 运算符 | 含义 |
| ----- | ----- | :----- |
| PLUS  | +     | 加法 |
| MINUS | -     | 减法 |
| MUL   | *     | 乘法 |
| DIV   | /     | 除法 |
| DIV2  | \\    | 整除 |
| MOD   | %     | 取摸 |

二进制位运算

| 助记符   | 运算符 | 含义 |
| ------- | ----- | :----- |
| AND     | &     | 按位于运算 |
| OR      | &#124;| 按位或运算 |
| NOT     | !     | 按位取反 |
| XOR     | ^     | 异或 |
| LSHIFT  | \<<   | 左位移 |
| RSHIFT  | \>>   | 有符号右位移 |
| RSHIFT2 | \>>>  | 无符号右位移 |

逻辑运算

| 助记符   | 运算符 | 含义 |
| ------- | ----- | :----- |
| GT      | \>    | 大于 |
| GE      | \>=   | 大于等于 |
| LT      | <     | 小于 |
| LE      | <=    | 小于等于 |
| EQ      | ==    | 等于 |
| NE      | !=    | 不等于 |
| SC_OR   | &#124;&#124; | 逻辑或 |
| SC_AND  | && | 逻辑与 |

### 3 数据类型
&emsp;&emsp;DataQL 是弱类型的查询语言。在DataQL 中所有数据都会被归结到有限的几种类型上。在弱类型系统中编写查询会非常方便，它去掉了繁杂的类型定义。
弱类型也带来了明显的问题：
- 字段不确定性：在没有搭配辅助的转换函数情况下，字段类型会具有不确定性。即：它有可能是 boolean 也有可能是字符串，这具体要看用户数据的原始返回的数据类型。

#### 3.1 类型定义
- 布尔类型
  - 取值范围是：true、false。
- 数值类型
  - 浮点数、整数、科学计数法表示的数。数值范围是：负无穷大/0/正无穷大。
- 字符串
  - 使用单引号或双引号圈定起来的字符数据。
- 空值
  - null。
- 集合
  - 数组或集合；多维的数组或集合。
- 对象
  - 具有键值对的数据体。与 Java 或 JavaScript 中的对象不同的是 DataQL 的对象不具备方法。但可以具备一个类型为 UDF 的属性来充当方法。
- UDF
  - 一个外部的 Udf 接口函数定义。
  - DataQL 中书写的 lambda 函数也被称作为 Udf。
  - 一个扩展代码片段的定义，也属于 Udf 的范畴。

#### 3.2 数据的表示
- 布尔类型
  - 举例：var bool = true;
- 数值类型
  - 二进制表示法：0b01010101100 或 0B01010101100
  - 十进制表示法：0o1234567 或 0O1234567
  - 八进制表示法：-0000234 或 123
  - 十六进制表示法：0x12345 或 0X12345
  - 科学计数法：a * 10的n次幂的形式，其中 1 < a ＜ 10
  - 关于负数：目前只有十进制表示法中提供了负数的表示能力。
- 字符串
  - 举例：var str = 'abcdefg...'; 或 var str = "abcdefg...";
  - 空字符串：var empty = ''; 或 var empty = "";
  - Unicode字符表示：var unicode = '\u0041'; //拉丁字母 A
- 空值
  - 举例：null
- 集合
  - 格式：[...]
  - 空集合：[]
  - 多维集合：[[...],[...]]
- 对象
  - 格式：{"k1": ... ,"k2": ...}
  - 空对象：{}
  - 多层结构：{"k1": { ... }, "k2": { ... } }
- UDF
  - 外部Udf：外部的 Udf 被引入之后，通常以标识符形式表示它。
  - DataQL 中书写的 lambda 表达方式为：var foo = () -> { /* 代码块 */ }
  - 外部代码片段： var a = @@xxx() <% /* 外部代码块 */ %>
- JSON
  - DataQL 可以直接表达 Json 数据，不过作为 json 的 Key 必须通过双引号或单引号形式包裹起来。

#### 3.3 类型提升
&emsp;&emsp;类型提升：两个操作数之间做运算时，其中一个数值类型和另外一个数值的类型不一致情况下。将两个数值的类型统一转换成同一种类型的行为。
- 提示：由于 DataQL 是弱类型的，因此 DataQL 语法上不会存在类似强制类型转换的写法。因此 `类型提升` 这个特性并不要求所有 DataQL 的运行时都给予支持。

&emsp;&emsp;以 Java 引擎的数值类型表示范围来参照，数值被分为下面几种形式
- 字节型(byte)，长度8， 取值范围：-128 ~ 127
- 短整型(sort)，长度16，取值范围：-32768 ~ 32768
- 整型(int)，长度32，取值范围：-2147483648 ~ 2147483648
- 长整型(long)，长度64，取值范围：-9233372036854477808 ~ 9233372036854477808
- 浮点型(float)，长度32，取值范围：-3.40292347E+38 ~ 3.40292347E+38
- 双精度(double)，长度64，取值范围：-1.79769313486231570E+308 ~ 1.79769313486231570E+308
- 大整数(BigInteger)，取值范围：java.math.BigInteger
- 大浮点数(BigDecimal)，取值范围：java.math.BigDecimal

Java 引擎中类型自动提升行为表

|            | bool       | byte       | sort       | int        | long       | float      | double     | BigInteger | BigDecimal | string    |
| ---------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :-------:  | :-------: |
| bool       | -          | byte       | sort       | int        | long       | float      | double     | BigInteger | BigDecimal | string    |
| byte       | byte       |  -         | sort       | int        | long       | float      | double     | BigInteger | BigDecimal | string    |
| sort       | sort       | sort       | -          | int        | long       | float      | double     | BigInteger | BigDecimal | string    |
| int        | int        | int        | int        | -          | long       | double     | double     | BigInteger | BigDecimal | string    |
| long       | long       | long       | long       | long       | -          | double     | double     | BigInteger | BigDecimal | string    |
| float      | float      | float      | float      | double     | double     | -          | double     | BigDecimal | BigDecimal | string    |
| double     | double     | double     | double     | double     | double     | double     | -          | BigDecimal | BigDecimal | string    |
| BigInteger | BigInteger | BigInteger | BigInteger | BigInteger | BigInteger | BigDecimal | BigDecimal | -          | BigDecimal | string    |
| BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | -          | string    |
| string     | string     | string     | string     | string     | string     | string     | string     | string     | string     | -

#### 3.4 数值默认宽度
&emsp;&emsp;数值表示的默认宽度，举例：`var = 235` 这个数即可是 byte 的也可能是 int 类型的。 默认宽度是指在 DataQL 查询语句中，定义的数字类型数据所使用的默认类型。
- 整数：byte、short、int(默认)、long、big
- 浮点数：float、double(默认)、big

&emsp;&emsp;修改默认数值计算宽度
- option MIN_DECIMAL_WIDTH = double
- option MIN_INTEGER_WIDTH = int

#### 3.5 浮点数
单精度float或者双精度double，由于其自身存储特性导致在做运算时出现精度丢失问题：
- 可以将浮点数的数值宽度提升到 big 就会以 BigDecimal 方式进行计算以解决精度丢失问题。缺点是性能损耗。

浮点数计算舍入精度
- 默认 20 位

修改浮点数计算舍入精度
- option MAX_DECIMAL_DIGITS = 20
    
舍入规则
- UP：向远离零的方向舍入。舍弃非零部分，并将非零舍弃部分相邻的一位数字加一。
- DOWN：向接近零的方向舍入。舍弃非零部分，同时不会非零舍弃部分相邻的一位数字加一，采取截取行为。
- CEILING：向正无穷的方向舍入。如果为正数，舍入结果同ROUND_UP一致；如果为负数，舍入结果同ROUND_DOWN一致。注意：此模式不会减少数值大小。
- FLOOR：向负无穷的方向舍入。如果为正数，舍入结果同ROUND_DOWN一致；如果为负数，舍入结果同ROUND_UP一致。注意：此模式不会增加数值大小。
- HALF_UP：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向上舍入的舍入模式。如果舍弃部分>= 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“四舍五入”。
- HALF_DOWN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则为向下舍入的舍入模式。如果舍弃部分> 0.5，则舍入行为与ROUND_UP相同；否则舍入行为与ROUND_DOWN相同。这种模式也就是我们常说的我们的“五舍六入”。
-  HALF_EVEN：向“最接近”的数字舍入，如果与两个相邻数字的距离相等，则相邻的偶数舍入。如果舍弃部分左边的数字奇数，则舍入行为与 ROUND_HALF_UP 相同；如果为偶数，则舍入行为与 ROUND_HALF_DOWN 相同。注意：在重复进行一系列计算时，此舍入模式可以将累加错误减到最小。此舍入模式也称为“银行家舍入法”，主要在美国使用。四舍六入，五分两种情况，如果前一位为奇数，则入位，否则舍去。*/
-  UNNECESSARY：断言请求的操作具有精确的结果，因此不需要舍入。如果对获得精确结果的操作指定此舍入模式，则抛出ArithmeticException。

更换舍入规则
-  例：option NUMBER_ROUNDING = "HALF_EVEN"

### 4.表达式
&emsp;&emsp;DataQL 具备完整的表达式计算能力，这使得数据在转换过程中在需要数值计算的情况上变得非常好用。对比 GraphQL 而言省去了编写大量 Udf 的操作。一个典型的场景就是是货币和汇率的转换。
```
return orderByUser({'id': 4}) => {
    'orderID',
    'price_rmb' : '¥' + (price_rmb * 6.9) + '元' ,
    'buyTime'
}
```

&emsp;&emsp;与普通 Java 或者 JavaScript 一样。DataQL 的表达式支持如下
- 四则运算
  - 数值运算
  - 二进制位运算
  - 逻辑运算
- 优先级
- 三元运算

#### 4.1 属性取值
&emsp;&emsp;DataQL 支持面向对象中的取值方式，例如下面几个例子：
```
// 返回用户ID为4的用户名
var userInfo = userByID({'id': 4});
return userInfo.username;

// 或者简写为：
return userByID({'id': 4}).username;

// 返回用户列表中第一条数据的用户名
return userList()[0].username;
```

#### 4.2 结构对象的下标取值
&emsp;&emsp;DataQL 支持类似 JavaScript 中那种通过下标的取值方式取值。在 DataQL 中有结构的数据只有两种：集合和Map。因此带有结构的对象类型数据，其就相当于一个Map，可以通过下面的方式来获取属性值。
```
// 返回用户ID为4的用户名
var userInfo = userByID({'id': 4});
return userInfo['username'];

// 或者简写为：
return userByID({'id': 4})['username'];

// 返回用户列表中第一条数据的用户名
return userList()[0]['username'];
```

#### 4.3 数组索引
&emsp;&emsp;对于数字形式的下标分为：`正向索引`、`反向索引` 两种。例如有一个数据集：
```
var list = [0,1,2,3,4,5,6,7,8,9]
```
- 正向索引：list[3] = 4 or list[5] = 5
  - 正数，从前向后数，从0开始。
- 反向索引：list[-3] = 7 or list[-5] = 5
  - 负数，从后向前数，从1开始。
- 索引溢出
  - 正向索引溢出：list[100]，取最后一个。
  - 反向索引溢出：list[-100]，取第一个。
        
#### 4.4 对象赋值
&emsp;&emsp;非常抱歉。DataQL 是专注于数据聚合查询的工具，并不是一门脚本语言。因此一些开发语言中的特性在 DataQL 中并不存在。赋值语句就是其中之一。
在比如对于修改返回结果中某一条数据中的一个值，这个场景也不属于 DataQL 的领域范畴。
您需要在业务维度将数据先准备好在交给 DataQL 做转换，或者您通过 lambda、Udf 等手段对数据进行批量处理。

- DataQL 是专注于数据流的，这也是 DataQL 的设计原则之一，因此对数据的逻辑处理 DataQL 并不十分擅长。

### 5 结果转换

语法形式为：
- `<表达式> => [ ... ]` 表达式结果作为集合类型迭代处理
  - 表达式为结构对象的情况下，将其变为一个元素的数组进行处理
- `<表达式> => { ... }` 表达式结果作为对象类型处理
  - 表达式值为集合元素的情况下，取得第一个元素进行处理

#### 5.1 转换为数组
&emsp;&emsp;调用用户程序的一个数据接口并获取到返回值，然后对返回的数据结果结构进行变换。这个就是结果转换。我们假定有一个用户列表接口它会返回一个 `List<User>` 类型结构，这个结构如下定义：
```java
long    userID = 1234567890;
int     age    = 31;
String  name   = "this is name.";
String  name2  = "this is name2.";
String  nick   = "my name is nick.";
SexEnum sex    = SexEnum.F; // 枚举 enum SexEnum { F, M }
boolean status = true;
```

&emsp;&emsp;我们返回给应用的数据结构中只含有 name 和 age，那么可以编写转换查询：
```
return userList() => [
    {
        'name': name,
        'age' : age
    }
]
```

&emsp;&emsp;这个查询中做了下面几个操作：
- 首先执行用户的 Udf 接口 userList()
- 接口返回数据将会作为 List 形式
- 把接口返回数据封装成为迭代器，并且迭代所有元素。
- 每次迭代元素的时都创建一个 两个元素的 Map 结构体作为新的结果。
- Map 中具有一个 name 属性，这个属性值的来源是迭代的当前元素中 name 属性。
- Map 中具有一个 age 属性，这个属性值的来源是迭代的当前元素中 age 属性。

#### 5.2 转换为对象
&emsp;&emsp;如果是数组转对象，相当于获取数组的第一个元素然后对这个元素对象进行结构转换。
```
return userList() => {
    'name': name,
    'age' : age
}
```

在这个例子中，转换语句可以简写为：
```
return userList() => {
    'name', 'age'
}
```

#### 5.3 转换为基本值类型数组
&emsp;&emsp;仍然以 `userList` 接口为例子，目前只需要返回所有用户的用户名即可，最终的结构应该是：`List<String>`
```
return userList() => [ name ]
```

&emsp;&emsp;这个查询中做了下面几个操作：
- 首先执行用户的 Udf 接口 userList()
- 接口返回数据将会作为 List 形式
- 把接口返回数据封装成为迭代器，并且迭代所有元素。
- 每次迭代都获取迭代的当前元素中 name 属性作为新的元素值。

#### 5.4 多维数组的转换
&emsp;&emsp;前面几种数组数据转换方式中，在转换过程中当前元素都是对象类型。可以直接通过对象属性方式获取所需要的值。
多维数组转换处理中，处理第一维转换期间需要获取整个当前元素。因此需要引入路由访问符 '#'
```
var data = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]

return data => [
    # => [
        "值：" + #
    ]
]

///  执行结果为：
[
    ["值：1","值：2","值：3"],
    ["值：4","值：5","值：6"],
    ["值：7","值：8","值：9"]
]
```

#### 6 路由访问符
&emsp;&emsp;在介绍路由之前需要先说明 DataQL 运行时的内存结构。DataQL 运行时内存结构是：两栈一堆模型。
- 栈：后入先出，插入删除在栈顶操作。
- 堆：在 DataQL 运行时，一个带有 parent 属性的一维数组就是堆。对堆的操作就是读写这个带 parent 的一维数组。

所谓两栈一堆就是有两个栈模型一个堆模型它们分别的意义是：
- 数据栈：
- 环境栈：
- 数据堆：在函数或者查询中定义的一些基本类型的变量和对象的引用变量都在数据堆内存中分配。例如：var 语句产生的临时变量。与 Java 不同的是 DataQL 的堆是一个二叉树结构，当进入一个函数之后 DataQL 运行时会自动为其分配一个新的堆空间，函数执行完毕之后会释放这个堆空间。





路由：
    可选的符号：@、#、$

    一般路由取值原理：
        首先将环境栈顶对象 copy 到数据栈顶，然后在数据栈顶的元素身上执行路由取值。

    $ss.sss.sss 是一般路由的升级形式：
        # 表示环境栈顶(同一般路由)，@ 表示第二层环境栈元素，$ 根环境栈元素（每一个结果转换都会产生一层环境栈）

    ${xxxx} 自定义取值


路由中单独只使用符号
    @，取上一层数据栈的数据
    #，取当前数据栈的数据
    $，取数据栈栈根数据
    例如：
        var _0 = [1,2,3,4,5,6] ; return ${_0} => { 'a': $ }  -> 结果为 { 'a' : 1 }





### 7 函数
函数和调用：
    DataQL 中的对象都是数据对象，类似 'var a = abs(123)' 这样的语句执行实际是，从环境对象上获取 abs 属性。
    而 abs 属性是一个 UDF 类型对象。这一点不同于 java 的对象方法调用。


### 8 执行外部代码片段
