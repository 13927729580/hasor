# DataQL

## 介绍
&emsp;&emsp;DataQL（Data Query Language）DataQL 是一种查询语言，旨在通过提供直观、灵活的语法来描述客户端应用程序的数据需求和交互。
例如：下面这个 DataQL 从 user 函数中查询 id 为 4 的用户相关信息并返回给应用。与对标开源工具 GraphQL 相比也仅仅这一部分与其是类似的。
```
return userByID({'id': 4}) => {
    'name',
    'sex'
    'age',
}
```

&emsp;&emsp;数据的存储根据其业务形式通常是较为简单的，并不适合直接在页面上进行展示。因此开发页面的前端工程师需要为此做大量的工作。
例如：性别数据的字典映射。 为此您可以通过 DataQL 的表达式进行快速的转换。从而无需任何服务端和前端的开发。
```
return userByID({'id': 4}) => {
    'name',
    'sex' : (sex == 'F') ? '男' : '女' ,
    'age'
}
```

&emsp;&emsp;DataQL 也允许您定义一个查询函数来重用这一逻辑。
```
var sex_str = (sex) -> {
    return (sex == 'F' ? '男' : '女');
}
return userByID({'id': 4}) => {
    'name',
    'sex' : sex_str(sex),
    'age'
}
```

DataQL 有一些设计原则，这也使其成为有一定的特性。
- 层次结构：大多数产品开发都涉及到数据的层次结构，为了实现与这些应用程序结构的一致性，DataQL 查询结果是也是分层结构的。这与 GraphQL 是基本相同的。
- 数据为中心：DataQL 不局限于只为前端工程师提供支持，当然前端工程师是一个比较典型的场景。对于后端工程师而言也有通过 DataQL 来构建业务的可配置化实践。
- 弱类型：DataQL 系统中不会要求声明任何形式的类型结构，您只需要在需要需要的时候描述它们即可。
- 逻辑表达：DataQL 并不是一门脚本语言。相比Java、Python这类专门的语言而言它对逻辑的表达能力较弱，但它的一些增强特性使其在对数据查询的过程中有了一些脚本的能力。例如：表达式计算、对象取值、条件分支、lambda和函数。
- 查询复用：DataQL 允许您在编写查询语句中通过 import 导入其它查询脚本使其作为当前查询中的一部分以供使用，这个特性会让您更加合理的规划和涉及基于 DataQL 的查询系统。从而降低脚本维护成本。
- 编译运行：查询的执行是基于编译结果的。这与 GraphQL 有很大的不同。原则上说只要任何一门特定的语言实现了 DataQL 的指令集，DataQL 就可以无缝直接被该平台兼容。这是这种一次编译到处运行的设计理念。
- 扩展代码片段：这是主要面向后端应用场景的一项特性。基于扩展代码片段，允许一个 DataQL 查询中可以混合任意的其它脚本语句。一个典型的场景是：在 DataQL 中定义 SQL 语句并通过代码片段来执行它，最后在利用 DataQL 对查询结果进行处理。
- 类JavaScript语法：DataQL 的语法设计绝大部分风格来自于 JavaScript，这使得使用者的学习成本变得极低。您可以在最快半个小时之内就可以上手使用并投入到生产环境。

&emsp;&emsp;基于这些原则和特性，DataQL变为构建应用程序的强大而高效的环境。此外构建 DataQL 环境您不需要单独搭建任何服务器。
目前 DataQL 只提供了 Java 版的指令执行引擎，使用这个引擎您只需要依赖一个 Jar 包即可。这相比较 GraphQL 需要专门服务器而言您的引入成本变得无比小，任何一个Web应用或者Spring Boog的 jar 应用使用都变得非常容易。

&emsp;&emsp;以下正式的语法规范可以用来帮助您更深入的了解如何使用 DataQL 的所有特性。在不同的语言平台上下面这些语法是通用的，在某些细节上各个平台在数据处理中可能有一些差异。例如：浮点数精度问题、超大数的宽度上下限。

----

## 语法部分

### 1 源码文本
&emsp;&emsp;DataQL 文档表示建议使用 Unicode字符序列。但这并不是强制的，您可以通过 java.io.Reader 来读取您的字符流数据。顾本文不会强调您的编写查询语言所使用的字符集。

&emsp;&emsp;DataQL 支持单行注释和多行注释两种注释方式。与 JavaScript 一样，您可以使用："//"、"/* ... */" 的形式进行代码注释。被注释的代码会被语法解析器忽略。
- 单行注释：以 "//" 开头后面的当前换行符内的所有内容均为注释内容。
- 多行注释：以 "/\*" 开始直到遇到 "\*/" 为止，中间的所有内容均为注释。

### 2 词法记号

#### 2.1 空白字符
&emsp;&emsp;空白字符用于提高源文本的可读性，并作为标记之间的分隔，任何数量的空白都可能出现在任何标记之前或之后。标记之间的空白对于 DataQL 文档的语义意义并不重要。
- DataQL 会把这些字符识别为空白字符："(空格)"、"\t"、"\n"、"\r"、"\f"

#### 2.2 关键字
| 关键字 | 含义 |
| ------ | :----- |
| if     | 条件语句的引导词。 |
| else   | 用在条件语句中，表明当条件不成立时的分支。 |
| return | 三大退出指令之一，终止当前过程的执行并正常退出到上一个执行过程中。 |
| throw  | 三大退出指令之一，终止所有后续指令的执行并抛出异常。 |
| exit   | 三大退出指令之一，终止所有后续指令的执行并正常退出。 |
| var    | 执行一个查询动作，并把查询结果保存到临时变量中。 |
| run    | 仅仅执行查询动作，不保留查询的结果。 |
| hint   | 写在 DataQL 查询语句的最前面，用于设置一些执行选项参数。  |
| import | 将另外一个 DataQL 查询导入并作为一个 Udf 形式存在、或直接导入一个 Udf 导入到当前查询中。 |
| as     | 与 import 关键字配合使用，用作将导入的 Udf 命名为一个本地变量名。 |
| true   | 基础类型之一，表示 Boolean 的：真值。 |
| false  | 基础类型之一，表示 Boolean 的：假值。 |
| null   | 基础类型之一，表示 NULL 值。 |

#### 2.3 标识符
&emsp;&emsp;在编写 DataQL 中用来表示查询中的一些实体。例如：变量名、参数名
- 标识符必须满足正则表达式：[_a-zA-Z][_0-9a-zA-Z]*

#### 2.4 分割符
&emsp;&emsp;主要用于分割语义。例如：表达式计算中的提权；语句块的包裹；函数入参的圈定等等。DataQL 的分割符有下面几种：

| 分割符 | 含义 |
| ----- | :----- |
| ()    | 函数入参的圈定，表达式中的计算项提取权。 |
| {}    | 用来定义复合语句。 |
| []    | 对数据通过下标方式取值操作。 |
| ,     | 不同参数的分割；对象键值对或数组元素之间的分割。 |
| :     | 对象键值对，键和值之间的分割。 |
| ;     | 语句的结束，DataQL 会自动推断语句结束，因此语句结束分割符并不是必须的。 |

#### 2.5 运算符

数值运算

| 助记符 | 运算符 | 含义 |
| ----- | ----- | :----- |
| PLUS  | +     | 加法 |
| MINUS | -     | 减法 |
| MUL   | *     | 乘法 |
| DIV   | /     | 除法 |
| DIV2  | \\    | 整除 |
| MOD   | %     | 取摸 |

二进制位运算

| 助记符   | 运算符 | 含义 |
| ------- | ----- | :----- |
| AND     | &     | 按位于运算 |
| OR      | &#124;| 按位或运算 |
| NOT     | !     | 按位取反 |
| XOR     | ^     | 异或 |
| LSHIFT  | \<<   | 左位移 |
| RSHIFT  | \>>   | 有符号右位移 |
| RSHIFT2 | \>>>  | 无符号右位移 |

逻辑运算

| 助记符   | 运算符 | 含义 |
| ------- | ----- | :----- |
| GT      | \>    | 大于 |
| GE      | \>=   | 大于等于 |
| LT      | <     | 小于 |
| LE      | <=    | 小于等于 |
| EQ      | ==    | 等于 |
| NE      | !=    | 不等于 |
| SC_OR   | &#124;&#124; | 逻辑或 |
| SC_AND  | && | 逻辑与 |

### 3 数据类型
&emsp;&emsp;DataQL 是弱类型的查询语言。在DataQL 中所有数据都会被归结到有限的几种类型上。在弱类型系统中编写查询会非常方便，它去掉了繁杂的类型定义。
弱类型也带来了明显的问题：
- 字段不确定性：在没有搭配辅助的转换函数情况下，字段类型会具有不确定性。即：它有可能是 boolean 也有可能是字符串，这具体要看 DataQL 的原始查询返回的数据类型。

#### 3.1 类型定义
- 布尔类型
  - 取值范围是：true、false。
- 数值类型
  - 浮点数、整数、科学计数法表示的数。数值范围是：负无穷大/0/正无穷大。
- 字符串
  - 使用单引号或双引号圈定起来的字符数据。
- 空值
  - null。
- 集合
  - 数组或集合；多维的数组或集合。
- 对象
  - 具有键值对的数据体。与 Java 或 JavaScript 中的对象不同的是 DataQL 的对象不具备方法。但可以具备一个类型为 UDF 的属性来充当方法。
- UDF
  - 一个外部的 Udf 接口函数定义。
  - DataQL 中书写的 lambda 函数也被称作为 Udf。
  - 一个扩展代码片段的定义，也属于 Udf 的范畴。

#### 3.2 数据的表示
- 布尔类型
  - 举例：var bool = true;
- 数值类型
  - 二进制表示法：0b01010101100 或 0B01010101100
  - 十进制表示法：0o1234567 或 0O1234567
  - 八进制表示法：-0000234 或 123
  - 十六进制表示法：0x12345 或 0X12345
  - 科学计数法：a * 10的n次幂的形式，其中 1 < a ＜ 10
  - 关于负数：目前只有十进制表示法中提供了负数的表示能力。
- 字符串
  - 举例：var str = 'abcdefg...'; 或 var str = "abcdefg...";
  - 空字符串：var empty = ''; 或 var empty = "";
  - Unicode字符表示：var unicode = '\u0041'; //拉丁字母 A
- 空值
  - 举例：null
- 集合
  - 格式：[...]
  - 空集合：[]
  - 多维集合：[[...],[...]]
- 对象
  - 格式：{"k1": ... ,"k2": ...}
  - 空对象：{}
  - 多层结构：{"k1": { ... }, "k2": { ... } }
- UDF
  - 外部Udf：外部的 Udf 被引入之后，通常以标识符形式表示它。
  - DataQL 中书写的 lambda 表达方式为：var foo = () -> { /* 代码块 */ }
  - 外部代码片段： var a = @@xxx() <% /* 外部代码块 */ %>

#### 3.3 类型提升
&emsp;&emsp;类型提升：两个操作数之间做运算时，其中一个数值类型和另外一个数值的类型不一致情况下。将两个数值的类型统一转换成同一种类型的行为。
- 提示：由于 DataQL 是弱类型的，因此 DataQL 语法上不会存在类似强制类型转换的写法。因此 `类型提升` 这个特性并不要求所有 DataQL 的运行时都给予支持。

&emsp;&emsp;以 Java 引擎的数值类型表示范围来参照，数值被分为下面几种形式
- 字节型(byte)，长度8， 取值范围：-128 ~ 127
- 短整型(sort)，长度16，取值范围：-32768 ~ 32768
- 整型(int)，长度32，取值范围：-2147483648 ~ 2147483648
- 长整型(long)，长度64，取值范围：-9233372036854477808 ~ 9233372036854477808
- 浮点型(float)，长度32，取值范围：-3.40292347E+38 ~ 3.40292347E+38
- 双精度(double)，长度64，取值范围：-1.79769313486231570E+308 ~ 1.79769313486231570E+308
- 大整数(BigInteger)，取值范围：java.math.BigInteger
- 大浮点数(BigDecimal)，取值范围：java.math.BigDecimal

Java 引擎中类型自动提升行为表

|            | bool       | byte       | sort       | int        | long       | float      | double     | BigInteger | BigDecimal |
| ---------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------: | :--------  |
| bool       | -          | byte       | sort       | int        | long       | float      | double     | BigInteger | BigDecimal |
| byte       | byte       |  -         | sort       | int        | long       | float      | double     | BigInteger | BigDecimal |
| sort       | sort       | sort       | -          | int        | long       | float      | double     | BigInteger | BigDecimal |
| int        | int        | int        | int        | -          | long       | double     | double     | BigInteger | BigDecimal |
| long       | long       | long       | long       | long       | -          | double     | double     | BigInteger | BigDecimal |
| float      | float      | float      | float      | double     | double     | -          | double     | BigDecimal | BigDecimal |
| double     | double     | double     | double     | double     | double     | double     | -          | BigDecimal | BigDecimal |
| BigInteger | BigInteger | BigInteger | BigInteger | BigInteger | BigInteger | BigDecimal | BigDecimal | -          | BigDecimal |
| BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | BigDecimal | -          |

### 4.表达式
&emsp;&emsp;DataQL 具备完整的表达式计算能力，这使得数据在转换过程中在需要数值计算的情况上变得非常好用。对比 GraphQL 而言省去了编写大量 Udf 的操作。一个典型的场景就是是货币和汇率的转换。
```
return orderByUser({'id': 4}) => {
    'orderID',
    'price_rmb' : '¥' + (price_rmb * 6.9) + '元' ,
    'buyTime'
}
```

&emsp;&emsp;与普通 Java 或者 JavaScript 一样。DataQL 的表达式支持如下
- 四则运算
  - 数值运算
  - 二进制位运算
  - 逻辑运算
- 优先级
- 三元运算

#### 4.1 属性取值
&emsp;&emsp;DataQL 支持面向对象中的取值方式，例如下面几个例子：
```
// 返回用户ID为4的用户名
var userInfo = userByID({'id': 4});
return userInfo.username;

// 或者简写为：
return userByID({'id': 4}).username;

// 返回用户列表中第一条数据的用户名
return userList()[0].username;
```

#### 4.2 结构对象的下标取值
&emsp;&emsp;DataQL 支持类似 JavaScript 中那种通过下标的取值方式取值。在 DataQL 中有结构的数据只有两种：集合和Map。因此带有结构的对象类型数据，其就相当于一个Map，可以通过下面的方式来获取属性值。
```
// 返回用户ID为4的用户名
var userInfo = userByID({'id': 4});
return userInfo['username'];

// 或者简写为：
return userByID({'id': 4})['username'];

// 返回用户列表中第一条数据的用户名
return userList()[0]['username'];
```

#### 4.3 数组对象的下标取值
&emsp;&emsp;对于常规数组下标取值只要填写要获取的元素索引编号即可。负数表示从后向前，正数表示从前向后。
```
// 返回用户列表中最后一条数据的用户名
return userList()[-1].username;
```

- 数组下标为负数表示，获取数据使用的索引编号是从后向前的。
  - 从前向后取值，0 代表第一个元素。
  - 从后向前取值，-1 代表最后一个元素。


#### 4.4 对象赋值
&emsp;&emsp;非常抱歉。DataQL 是专注于数据聚合查询的工具，并不是一门脚本语言。因此一些开发语言中的特性在 DataQL 中并不存在。赋值语句就是其中之一。
在比如对于修改返回结果中某一条数据中的一个值，这个场景也不属于 DataQL 的领域范畴。您需要在业务维度将数据先准备好在交给 DataQL 做转换。

&emsp;&emsp;因此 DataQL 可以说专注于数据流的，这也是 DataQL 的设计原则之一。

### 5 结果转换

语法形式为：
- `<表达式> => [ ... ]` 表达式结果作为集合类型迭代处理
  - 表达式为结构对象的情况下，将其变为一个元素的数组进行处理
- `<表达式> => { ... }` 表达式结果作为对象类型处理
  - 表达式值为集合元素的情况下，取得第一个元素进行处理

#### 5.1 数组 - 不同结构的转换
&emsp;&emsp;调用用户程序的一个数据接口并获取到返回值，然后对返回的数据结果结构进行变换。这个就是结果转换。我们假定有一个用户列表接口它会返回一个 `List<User>` 类型结构，这个结构如下定义：
```java
long    userID = 1234567890;
int     age    = 31;
String  name   = "this is name.";
String  name2  = "this is name2.";
String  nick   = "my name is nick.";
SexEnum sex    = SexEnum.F; // 枚举 enum SexEnum { F, M }
boolean status = true;
```

&emsp;&emsp;我们返回给应用的数据结构中只含有 name 和 age，那么可以编写转换查询：
```
return userList() => [
    {
        'name': name,
        'age' : age
    }
]
```

&emsp;&emsp;这个查询中做了下面几个操作：
- 首先执行用户的 Udf 接口 userList()
- 接口返回数据将会作为 List 形式
- 把接口返回数据封装成为迭代器，并且迭代所有元素。
- 每次迭代元素的时都创建一个 两个元素的 Map 结构体作为新的结果。
- Map 中具有一个 name 属性，这个属性值的来源是迭代的当前元素中 name 属性。
- Map 中具有一个 age 属性，这个属性值的来源是迭代的当前元素中 age 属性。

#### 5.2 数组 - 结构转为基本值
&emsp;&emsp;仍然以 `userList` 接口为例子，目前只需要返回所有用户的用户名即可，最终的结构应该是：`List<String>`
```
return userList() => [ name ]
```

&emsp;&emsp;这个查询中做了下面几个操作：
- 首先执行用户的 Udf 接口 userList()
- 接口返回数据将会作为 List 形式
- 把接口返回数据封装成为迭代器，并且迭代所有元素。
- 每次迭代都获取迭代的当前元素中 name 属性作为新的元素值。

#### 5.3 数组转为对象
&emsp;&emsp;数组转对象，相当于获取数组的第一个元素然后对这个元素对象进行结构转换。
```
return userList() => {
    'name': name,
    'age' : age
}
```

#### 5.4 多维数组的转换
&emsp;&emsp;前面几种数组数据转换方式中，在转换过程中当前元素都是对象类型。可以直接通过对象属性方式获取所需要的值。
多维数组转换处理中，处理第一维转换期间需要获取整个当前元素。因此需要引入路由访问符 '#'
```
var data = [
    [1,2,3],
    [4,5,6],
    [7,8,9]
]

return data => [
    # => [
        "值：" + #
    ]
]

///  执行结果为：
[
    ["值：1","值：2","值：3"],
    ["值：4","值：5","值：6"],
    ["值：7","值：8","值：9"]
]
```





结果转换
    对象
        对象结构转换
        对象转换为数组
        转换中的简写


### 6 服务聚合
